#pragma once
#include <iostream>

/*
Разработать класс MyString
Класс должен содержать методы для ввода строк с клавиатуры и вывода строк на экран и деструктор.
Также нужно реализовать статическую функцию-член, которая будет возвращать количество созданных объектов-строк.
Класс должен содержать:
1. Конструктор по умолчанию, позволяющий создать строку длиной 80 символов;
2. Конструктор, позволяющий создавать строку произвольного размера (принимает количество символов, из которых будет состоять строка);
3. Конструктор, который создаёт строку и инициализирует её строкой, полученной в виде параметра этого конструктора;
4. Конструктор, который создаёт строку и инициализирует её строкой, полученной от пользователя (с клавиатуры).
5. Перегрузить оператор + (он будет работать как конкатенация строк)
6. Перегрузить оператор ++ (добавление к концу нашего объекта-строки одного символа 'x')
7. Перегрузить оператор -- (удаление одного символа из конца нашего объекта-строки)
8. Перегрузить оператор <
9. Перегрузка оператора + для ситуации: int + MyString (к строке ххх + MyString )
*/

class MYString                 // класс MYString
{                              
    char* String_;             // Строка 
    int Length_;               // Длина строки 
    static int creating_OBJ;   // Статическая функция (количество созданных объектов-строк)

public:
// _______________________________________________________________________________________________________________________________//
//                                                    Constructors
// _______________________________________________________________________________________________________________________________//
    MYString()                            // 1. (Конструктор по умолчанию, позволяющий создать строку длиной 80 символов)
    {                                     
        Length_ = 80;                     // Длина 80 символов 
        String_ = new char[Length_ + 1];  // Строка с размером 80 символов + '\0'
        creating_OBJ++;
    }
// _______________________________________________________________________________________________________________________________
    MYString(size_t size)                 // 2. (Конструктор, позволяющий создавать строку произвольного размера)
    {
        std::cout << "Size = " << size << std::endl;
        Length_ = size;                   // Получаем размер от пользователя
        String_ = new char[Length_ + 1];  // Cоздаем строку размером от пользователя + '\0'
        creating_OBJ++;                           
    }
// _______________________________________________________________________________________________________________________________
    MYString(const char* temp_String)      // 3. (Конструктор, создаёт строку и инициализирует её строкой,
    {                                      //    полученной в виде параметра этого конструктора)    
        Length_ = strlen(temp_String);     // Принимаем строку от пользоваетля и узнаем ее размер 
        String_ = new char[Length_ + 1];   // Наша строка принимает размер строки от пользователя
        strcpy_s(String_, Length_ + 1, temp_String);  // копируем строку от пользователя + избегаем переполнение буфера
        //       | <- <- <- <- (BUFF) <- <- <- |
        creating_OBJ++;
    }
// _______________________________________________________________________________________________________________________________
    MYString(const MYString& temp_String)      // 4. (Конструктор, копирования который создаёт строку,
    {                                          // полученной от пользователя (с клавиатуры) )
        Length_ = strlen(temp_String.String_);
        String_ = new char[Length_ + 1];
        strcpy_s(String_, Length_ + 1, temp_String.String_);
        creating_OBJ++;
        
    }
// _______________________________________________________________________________________________________________________________//
//                                                    Overloads
// _______________________________________________________________________________________________________________________________//
    MYString operator+(const MYString& temp_String)     // 5. Перегрузить оператор + (он будет работать как конкатенация строк)
    {
        MYString temp_str;
        temp_str.Length_ = this->Length_ + temp_String.Length_;
        temp_str.String_ = new char[temp_str.Length_ + 1];
        strcpy_s(temp_str.String_, temp_str.Length_ + 1, String_);
        strcat_s(temp_str.String_, temp_str.Length_+ 1,temp_String.String_);
        return temp_str;
    }
// _______________________________________________________________________________________________________________________________//
    MYString operator++()             // 6. Перегрузить оператор ++ (добавление к концу нашего объекта-строки одного символа 'x')
    {
        char symbol[10]{"xxx"};
        MYString temp_str;
        temp_str.Length_ = this->Length_ + strlen(symbol) + 1;
        temp_str.String_ = new char[temp_str.Length_ + 1];
        strcpy_s(temp_str.String_, temp_str.Length_ + 1, String_);
        strcat_s(temp_str.String_, temp_str.Length_ + 1, symbol);

        this->String_ = new char[temp_str.Length_ + 1];
        strcpy_s(String_, temp_str.Length_ + 1, temp_str.String_);

        return *this;
    }
// _______________________________________________________________________________________________________________________________
    MYString operator--()             // 7. Перегрузить оператор -- (удаление одного символа из конца нашего объекта-строки)
    {
        MYString temp_str;  // Внутри метода класса создаем переменную
        temp_str.Length_ = strlen(this->String_);               //  применяем шаблонный алгоритм для строки с выделение памяти 
        temp_str.String_ = new char[temp_str.Length_ + 1];      
        // Нам нужно перебрать массив и удалить один символа из конца
        int i = NULL;  // инициализируем переменную типа int для массива символов 
        for (i = 0; i < temp_str.Length_ - 1; i++)
        {
            temp_str.String_[i] = String_[i];  // передаем символы из объекта класса в наш временный объект 
        }
        temp_str.String_[i] = 0;  // конец строки объекта 
        this->String_ = new char[temp_str.Length_ + 1];  // для основоного объекта шаблонный алгоритм выделение памяти
        strcpy_s(String_, temp_str.Length_ + 1, temp_str.String_);  // копируем наш временный в основной с учетом -1 символ 

        return *this;  // возвращаем конст - указатель нашего объекта  
    }
// _______________________________________________________________________________________________________________________________
    MYString operator<(const MYString temp_str)  // 8. Перегрузить оператор <
    {

    }
    void InpuT()                           // Функция ввода данных
    {
        if (String_ != nullptr)            // Делаем проверку если строка 
        {                                  // содержит в себе что-то мы ее удаляем
            delete[] String_;
        } 
        char Input_String[40];
        std::cout << "Enter a line : ";
        std::cin.getline(Input_String, 40);
        Length_ = strlen(Input_String) + 1;
        String_ = new char[Length_];
        strcpy_s(String_, Length_, Input_String);
    }

    void OutPut() const                          // Функция вывода данных
    {
        std::cout << "String received : " << String_ << std::endl;
    }

    static int Using_OBJ()
    {
        return creating_OBJ;
    }

    ~MYString()
    {
        creating_OBJ--;
        delete[] String_;
    }

};
// _______________________________________________________________________________________________________________________________
int MYString::creating_OBJ = 0;  //  статическое поле нужно обязательно инициализировать после создания класса
// _______________________________________________________________________________________________________________________________